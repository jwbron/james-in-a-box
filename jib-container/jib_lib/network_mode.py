"""Private mode configuration for jib.

This module manages the PRIVATE_MODE setting that controls both network
access and repository visibility:

- PRIVATE_MODE=true:  Private repos only, network locked down (Anthropic API only)
- PRIVATE_MODE=false: Public repos only, full internet access (default)

This single flag ensures you can't accidentally combine open network with
private repo access (a security anti-pattern that could lead to data exfiltration).

Mode is determined solely by CLI flags (--private or --public), with no
persistent state between invocations. Default is public mode.
"""

import json
import subprocess
import urllib.request
from enum import Enum

from .config import Config
from .output import error, info, warn


class PrivateMode(Enum):
    """Private mode options for jib.

    PRIVATE: Private repos only, network locked down (Anthropic API only)
    PUBLIC: Public repos only, full internet access (default)
    """

    PRIVATE = "private"
    PUBLIC = "public"


def get_private_mode_env_vars(mode: PrivateMode) -> dict[str, str]:
    """Get environment variables for the given private mode.

    Args:
        mode: The private mode.

    Returns:
        Dict of environment variable names to values.
    """
    if mode == PrivateMode.PRIVATE:
        # Private repos + locked network
        return {"PRIVATE_MODE": "true"}
    else:
        # Public repos + full internet
        return {"PRIVATE_MODE": "false"}


def _write_network_env_file(mode: PrivateMode) -> bool:
    """Write the private mode environment variable to a file.

    The gateway sidecar sources this file at startup.

    Args:
        mode: The private mode to write.

    Returns:
        True if successful, False otherwise.
    """
    env_vars = get_private_mode_env_vars(mode)

    env_file = Config.USER_CONFIG_DIR / "network.env"
    try:
        env_file.parent.mkdir(parents=True, exist_ok=True)
        lines = [f"# Auto-generated by jib - mode: {mode.value}"]
        for key, value in env_vars.items():
            lines.append(f"{key}={value}")
        env_file.write_text("\n".join(lines) + "\n")
        return True
    except OSError as e:
        error(f"Failed to write network.env file: {e}")
        return False


def get_gateway_current_mode() -> PrivateMode | None:
    """Query the gateway's current mode via health endpoint.

    Returns:
        The gateway's current PrivateMode, or None if gateway is not reachable.
    """
    try:
        with urllib.request.urlopen("http://localhost:9847/api/v1/health", timeout=2) as response:
            data = json.loads(response.read().decode("utf-8"))
            if data.get("private_mode"):
                return PrivateMode.PRIVATE
            else:
                return PrivateMode.PUBLIC
    except Exception:
        return None


def ensure_gateway_mode(mode: PrivateMode, quiet: bool = False) -> bool:
    """Ensure the gateway is running with the specified mode.

    Checks the gateway's current mode and restarts it if different from
    the requested mode. Also updates the network.env file so future
    gateway starts use the correct mode.

    Args:
        mode: The desired PrivateMode.
        quiet: Suppress output messages.

    Returns:
        True if gateway is running with correct mode, False on error.
    """
    # Always write the env file so gateway starts with correct mode
    if not _write_network_env_file(mode):
        return False

    # Check current gateway mode
    current_mode = get_gateway_current_mode()

    if current_mode is None:
        # Gateway not running - it will start with correct mode from env file
        if not quiet:
            info(f"Gateway not running - will start in {mode.value.upper()} mode")
        return True

    if current_mode == mode:
        # Already in correct mode
        return True

    # Need to restart gateway with new mode
    if not quiet:
        info(f"Restarting gateway: {current_mode.value} â†’ {mode.value}...")

    # Restart the gateway sidecar service
    result = subprocess.run(
        ["systemctl", "--user", "restart", "gateway-sidecar.service"],
        capture_output=True,
        text=True,
        check=False,
    )

    if result.returncode != 0:
        # Service might not be installed, try direct docker restart
        docker_result = subprocess.run(
            ["docker", "restart", "jib-gateway"],
            capture_output=True,
            text=True,
            check=False,
        )
        if docker_result.returncode != 0:
            if not quiet:
                warn("Could not restart gateway - please restart manually")
            return False

    if not quiet:
        if mode == PrivateMode.PRIVATE:
            info("Mode: PRIVATE (locked network + private repos)")
        else:
            info("Mode: PUBLIC (full internet + public repos)")

    return True
