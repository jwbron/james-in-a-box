"""Private mode configuration for jib.

This module manages the PRIVATE_MODE setting that controls both network
access and repository visibility:

- PRIVATE_MODE=true:  Private repos only, network locked down (Anthropic API only)
- PRIVATE_MODE=false: Public repos only, full internet access (default)

This single flag ensures you can't accidentally combine open network with
private repo access (a security anti-pattern that could lead to data exfiltration).

The mode is stored in ~/.config/jib/private-mode and read by the gateway
sidecar at startup.
"""

import subprocess
from enum import Enum

from .config import Config
from .output import error, info, warn


class PrivateMode(Enum):
    """Private mode options for jib.

    PRIVATE: Private repos only, network locked down (Anthropic API only)
    PUBLIC: Public repos only, full internet access (default)
    """

    PRIVATE = "private"
    PUBLIC = "public"


# Config file for private mode
PRIVATE_MODE_FILE = Config.USER_CONFIG_DIR / "private-mode"


def get_private_mode() -> PrivateMode:
    """Get the current private mode setting.

    Returns:
        The configured PrivateMode, defaults to PUBLIC if not set.
    """
    if not PRIVATE_MODE_FILE.exists():
        return PrivateMode.PUBLIC

    try:
        mode_str = PRIVATE_MODE_FILE.read_text().strip()
        return PrivateMode(mode_str)
    except (ValueError, OSError):
        return PrivateMode.PUBLIC


def set_private_mode(mode: PrivateMode) -> bool:
    """Set the private mode.

    Args:
        mode: The private mode to set.

    Returns:
        True if successful, False otherwise.
    """
    try:
        PRIVATE_MODE_FILE.parent.mkdir(parents=True, exist_ok=True)
        PRIVATE_MODE_FILE.write_text(mode.value)
        return True
    except OSError as e:
        error(f"Failed to write private mode: {e}")
        return False


def get_private_mode_env_vars(mode: PrivateMode) -> dict[str, str]:
    """Get environment variables for the given private mode.

    Args:
        mode: The private mode.

    Returns:
        Dict of environment variable names to values.
    """
    if mode == PrivateMode.PRIVATE:
        # Private repos + locked network
        return {"PRIVATE_MODE": "true"}
    else:
        # Public repos + full internet
        return {"PRIVATE_MODE": "false"}


def write_private_mode_env_file() -> bool:
    """Write the private mode environment variable to a file.

    The gateway sidecar sources this file at startup.

    Returns:
        True if successful, False otherwise.
    """
    mode = get_private_mode()
    env_vars = get_private_mode_env_vars(mode)

    env_file = Config.USER_CONFIG_DIR / "network.env"
    try:
        env_file.parent.mkdir(parents=True, exist_ok=True)
        lines = [f"# Auto-generated by jib - mode: {mode.value}"]
        for key, value in env_vars.items():
            lines.append(f"{key}={value}")
        env_file.write_text("\n".join(lines) + "\n")
        return True
    except OSError as e:
        error(f"Failed to write private mode env file: {e}")
        return False


def restart_gateway_if_mode_changed(quiet: bool = False) -> bool:
    """Restart the gateway service if mode has changed.

    This writes the current mode to the env file and restarts the
    gateway-sidecar systemd service.

    Args:
        quiet: Suppress output messages.

    Returns:
        True if gateway restarted successfully, False otherwise.
    """
    # Write the env file
    if not write_private_mode_env_file():
        return False

    if not quiet:
        info("Restarting gateway with new mode...")

    # Restart the gateway sidecar service
    result = subprocess.run(
        ["systemctl", "--user", "restart", "gateway-sidecar.service"],
        capture_output=True,
        text=True,
        check=False,
    )

    if result.returncode != 0:
        # Service might not be installed, try direct docker restart
        docker_result = subprocess.run(
            ["docker", "restart", "jib-gateway"],
            capture_output=True,
            text=True,
            check=False,
        )
        if docker_result.returncode != 0:
            if not quiet:
                warn("Gateway not running - will start with new mode on next run")
            return True  # Not a failure, gateway will start with new mode

    if not quiet:
        mode = get_private_mode()
        if mode == PrivateMode.PRIVATE:
            info("Mode: PRIVATE (locked network + private repos)")
        else:
            info("Mode: PUBLIC (full internet + public repos)")

    return True
