#!/usr/bin/env python3
"""
Incoming Message Processor

Processes a single incoming message or response from Slack.
Called by slack-receiver via `jib --exec` after writing a message file.

Usage:
  python3 incoming-processor.py <message-file>
"""

import sys
import subprocess
from pathlib import Path
from datetime import datetime


def process_task(message_file: Path):
    """Process an incoming task from Slack using Claude Code."""
    print(f"üìã Processing task: {message_file.name}")

    # Read full message content
    content = message_file.read_text()

    # Extract task description (after "## Current Message" header)
    task_lines = []
    in_message_section = False
    for line in content.split('\n'):
        if line.startswith('## Current Message'):
            in_message_section = True
            continue
        if in_message_section:
            if line.startswith('---'):
                break
            if line.strip():
                task_lines.append(line)

    task_content = '\n'.join(task_lines).strip()

    if not task_content:
        print("‚ö†Ô∏è Empty task content")
        return False

    print(f"Task: {task_content[:100]}...")

    # Construct prompt for Claude with full context
    prompt = f"""# Slack Task Processing

You received a task via Slack. Process it according to the workflow below.

## Message Details

**File:** `{message_file.name}`
**Received:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Task from User

{task_content}

## Your Workflow

1. **Understand the request**: Analyze what the user is asking for
2. **Track in Beads**: Add task to beads with `bd add` (include relevant tags)
3. **Execute the task**:
   - Read relevant code/documentation
   - Make necessary changes
   - Run tests if applicable
   - Commit changes with clear messages
4. **Create notification**: Write result to `~/sharing/notifications/` with:
   - Summary of what was done
   - Branch name (if commits were made)
   - Next steps for user
   - Any blockers or questions

## Important Notes

- You're in an ephemeral container (will exit when done)
- All work should be committed to git (user will review and push)
- Use beads to track progress across sessions
- Send notification so user gets Slack DM with results
- Working directory: You can access all repos in `~/khan/`

Process this task now."""

    # Run Claude Code via stdin (not --print which creates restricted session)
    # This allows full access to tools and filesystem
    # Important: Start in ~/khan/ and use bypass permissions
    try:
        result = subprocess.run(
            ["claude", "--dangerously-skip-permissions"],
            input=prompt,
            text=True,
            capture_output=True,  # Capture output to create notification
            timeout=600,  # 10 minute timeout
            cwd=str(Path.home() / "khan")  # Start in khan directory
        )

        if result.returncode == 0:
            print(f"‚úÖ Task processed successfully")

            # Create notification with Claude's response
            notifications_dir = Path.home() / "sharing" / "notifications"
            notifications_dir.mkdir(parents=True, exist_ok=True)

            # IMPORTANT: Preserve original task ID from message_file for threading
            # Extract task ID from original filename (e.g., "task-20251124-111907.md" ‚Üí "task-20251124-111907")
            original_task_id = message_file.stem  # Remove .md extension
            timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
            # Use original task ID so slack-notifier can find the thread
            notification_file = notifications_dir / f"{original_task_id}.md"

            notification_content = f"""# Task Response - {timestamp}

**Task:** {task_content[:100]}{'...' if len(task_content) > 100 else ''}

## Claude's Response

{result.stdout}

---
*Generated by james-in-a-box incoming processor*
"""

            notification_file.write_text(notification_content)
            print(f"üì¨ Notification created: {notification_file.name}")

            return True
        else:
            print(f"‚ö†Ô∏è Claude exited with code {result.returncode}")
            print(f"Error output: {result.stderr}")
            return False

    except subprocess.TimeoutExpired:
        print("‚ö†Ô∏è Task processing timed out after 10 minutes")
        return False
    except Exception as e:
        print(f"‚ùå Error running Claude: {e}")
        return False


def process_response(message_file: Path):
    """Process a user's response to a previous notification using Claude Code."""
    print(f"üí¨ Processing response: {message_file.name}")

    # Read response content
    content = message_file.read_text()

    # Extract referenced notification if present
    referenced_notif = None
    original_notif_content = None
    for line in content.split('\n'):
        if 'Re:**' in line and 'Notification' in line:
            # Extract timestamp from line like: **Re:** Notification `20251124-123456`
            parts = line.split('`')
            if len(parts) >= 2:
                referenced_notif = parts[1]
                break

    # Try to load original notification for context
    if referenced_notif:
        print(f"Response references: {referenced_notif}")
        notifications_dir = Path.home() / "sharing" / "notifications"
        original_file = notifications_dir / f"{referenced_notif}.md"
        if original_file.exists():
            original_notif_content = original_file.read_text()

    # Extract response content
    response_lines = []
    in_message_section = False
    for line in content.split('\n'):
        if line.startswith('## Current Message'):
            in_message_section = True
            continue
        if in_message_section:
            if line.startswith('---'):
                break
            if line.strip():
                response_lines.append(line)

    response_content = '\n'.join(response_lines).strip()

    if not response_content:
        print("‚ö†Ô∏è Empty response content")
        return False

    # Construct prompt for Claude with full context
    prompt = f"""# Slack Response Processing

You sent a notification that prompted a response from the user. Process their response and take appropriate action.

## Original Notification

{original_notif_content if original_notif_content else "*(Original notification not found)*"}

## User's Response

{response_content}

## Your Workflow

1. **Understand the response**: What is the user asking or telling you?
2. **Check Beads context**: Use `bd` to see related tasks and previous work
3. **Take appropriate action**:
   - If they answered a question: Continue the work
   - If they gave feedback: Incorporate it
   - If they requested changes: Make the changes
   - If they asked a question: Research and respond
4. **Update Beads**: Update task status as appropriate
5. **Create notification**: Send result back via `~/sharing/notifications/`

## Important Notes

- You're in an ephemeral container (will exit when done)
- All work should be committed to git
- Use beads to track progress and maintain context
- The user is responding in a Slack thread - keep them updated

Process this response now."""

    # Run Claude Code via stdin (not --print which creates restricted session)
    # This allows full access to tools and filesystem
    # Important: Start in ~/khan/ and use bypass permissions
    try:
        result = subprocess.run(
            ["claude", "--dangerously-skip-permissions"],
            input=prompt,
            text=True,
            capture_output=True,  # Capture output to create notification
            timeout=600,  # 10 minute timeout
            cwd=str(Path.home() / "khan")  # Start in khan directory
        )

        if result.returncode == 0:
            print(f"‚úÖ Response processed successfully")

            # Create notification with Claude's response
            notifications_dir = Path.home() / "sharing" / "notifications"
            notifications_dir.mkdir(parents=True, exist_ok=True)

            timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
            # IMPORTANT: Use referenced_notif (original task ID) for threading
            # If we have a referenced notification, use that ID so slack-notifier threads correctly
            if referenced_notif:
                notification_file = notifications_dir / f"{referenced_notif}.md"
            else:
                # Fallback if no reference found - extract from message filename
                notification_file = notifications_dir / f"{message_file.stem}.md"

            notification_content = f"""# Response Processed - {timestamp}

**Referenced Notification:** {referenced_notif if referenced_notif else 'None'}

## Claude's Response

{result.stdout}

---
*Generated by james-in-a-box incoming processor*
"""

            notification_file.write_text(notification_content)
            print(f"üì¨ Notification created: {notification_file.name}")

            return True
        else:
            print(f"‚ö†Ô∏è Claude exited with code {result.returncode}")
            print(f"Error output: {result.stderr}")
            return False

    except subprocess.TimeoutExpired:
        print("‚ö†Ô∏è Response processing timed out after 10 minutes")
        return False
    except Exception as e:
        print(f"‚ùå Error running Claude: {e}")
        return False


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: incoming-processor.py <message-file>", file=sys.stderr)
        return 1

    message_file = Path(sys.argv[1])

    if not message_file.exists():
        print(f"Error: File not found: {message_file}", file=sys.stderr)
        return 1

    # Determine message type based on parent directory
    if 'incoming' in str(message_file.parent):
        success = process_task(message_file)
    elif 'responses' in str(message_file.parent):
        success = process_response(message_file)
    else:
        print(f"Error: Unknown message type for {message_file}", file=sys.stderr)
        return 1

    # Stop background services before exiting (PostgreSQL, Redis keep container alive)
    # This ensures ephemeral jib --exec containers exit cleanly
    subprocess.run(["service", "postgresql", "stop"], capture_output=True)
    subprocess.run(["service", "redis-server", "stop"], capture_output=True)

    return 0 if success else 1


if __name__ == '__main__':
    sys.exit(main())
