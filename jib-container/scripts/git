#!/bin/bash
#
# Git wrapper for jib container
# Intercepts git commands to ensure proper authentication and security.
#
# This wrapper is placed in PATH before /usr/bin/git to:
# 1. Block remote URL modifications (URLs are managed by the host)
# 2. Route git push through the gateway sidecar for policy enforcement
#
# Authentication is handled by the gateway sidecar which holds the GITHUB_TOKEN.
#

REAL_GIT=/usr/bin/git
GATEWAY_URL="${GATEWAY_URL:-http://host.docker.internal:9847}"

# Function to show remote modification blocked message
show_remote_blocked_message() {
    cat >&2 << 'EOF'

================================================================================
  GIT REMOTE MODIFICATION BLOCKED
================================================================================

Git remote URLs are managed by the HOST and must not be modified.

If you need to interact with a different repository:
  - Clone it fresh or work in a different directory
  - The host manages remote URLs for security

================================================================================

EOF
    return 1
}

# Function to check if gateway is available
check_gateway_available() {
    if command -v curl >/dev/null 2>&1; then
        curl -s --connect-timeout 2 "${GATEWAY_URL}/api/v1/health" >/dev/null 2>&1
        return $?
    fi
    return 1
}

# Function to push via gateway
push_via_gateway() {
    local remote="$1"
    local refspec="$2"
    local force="$3"
    local repo_path
    repo_path=$(pwd)

    # Build JSON payload
    local payload
    if [ "$force" = "true" ]; then
        payload=$(cat <<EOF
{
    "repo_path": "$repo_path",
    "remote": "$remote",
    "refspec": "$refspec",
    "force": true
}
EOF
)
    else
        payload=$(cat <<EOF
{
    "repo_path": "$repo_path",
    "remote": "$remote",
    "refspec": "$refspec",
    "force": false
}
EOF
)
    fi

    # Call gateway
    local response
    local http_code
    response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Content-Type: application/json" \
        -d "$payload" \
        "${GATEWAY_URL}/api/v1/git/push" 2>&1)

    # Split response and status code
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Parse response
    local success
    local message
    success=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('success', False))" 2>/dev/null)
    message=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('message', 'Unknown error'))" 2>/dev/null)

    if [ "$success" = "True" ]; then
        # Show stdout/stderr from the push
        local stdout stderr
        stdout=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('data', {}).get('stdout', ''))" 2>/dev/null)
        stderr=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('data', {}).get('stderr', ''))" 2>/dev/null)
        [ -n "$stdout" ] && echo "$stdout"
        [ -n "$stderr" ] && echo "$stderr" >&2
        return 0
    else
        # Show error message
        echo "ERROR: $message" >&2

        # Show details if available
        local details
        details=$(echo "$response" | python3 -c "import sys, json; d=json.load(sys.stdin).get('data', {}); print(d.get('stderr', '') if d else '')" 2>/dev/null)
        [ -n "$details" ] && echo "$details" >&2

        # Special handling for policy denials
        if [ "$http_code" = "403" ]; then
            cat >&2 << 'EOF'

================================================================================
  PUSH BLOCKED BY POLICY
================================================================================

The gateway sidecar blocked this push operation.

To push, ensure one of the following:
  1. Use a jib-prefixed branch name: jib-* or jib/*
  2. Create a PR from this branch first (the branch will then be owned by jib)

================================================================================

EOF
        fi

        return 1
    fi
}

# Function to check if push target is HTTPS (we don't have SSH keys)
check_push_remote() {
    local remote="${1:-origin}"

    # Get the remote URL
    local url
    url=$("$REAL_GIT" remote get-url "$remote" 2>/dev/null)

    if [ -z "$url" ]; then
        echo "ERROR: Remote '$remote' not found" >&2
        return 1
    fi

    # Check if it's SSH - we can't push via SSH (no keys in container)
    if [[ "$url" == git@* ]] || [[ "$url" == ssh://* ]]; then
        cat >&2 << EOF

================================================================================
  SSH PUSH NOT SUPPORTED
================================================================================

Remote '$remote' uses SSH: $url

This container doesn't have SSH keys. To push, you have two options:

1. Change the remote URL on the HOST to HTTPS:
   git remote set-url $remote https://github.com/OWNER/REPO.git

2. Or push from the host machine directly

================================================================================

EOF
        return 1
    fi

    return 0
}

# Parse the git command
cmd=""
for arg in "$@"; do
    # Skip flags (start with -)
    if [[ "$arg" != -* ]]; then
        cmd="$arg"
        break
    fi
done

case "$cmd" in
    push)
        # Extract remote and refspec from push command
        # git push [options] [remote] [refspec...]
        remote="origin"
        refspec=""
        force="false"
        skip_next=false

        for arg in "$@"; do
            if $skip_next; then
                skip_next=false
                continue
            fi

            case "$arg" in
                push)
                    continue
                    ;;
                -f|--force|--force-with-lease*)
                    force="true"
                    ;;
                -u|--set-upstream)
                    # -u takes no extra argument
                    ;;
                --repo|--receive-pack|--exec|-o|--push-option)
                    # These flags take an argument
                    skip_next=true
                    ;;
                -*)
                    # Other flags, ignore
                    ;;
                *)
                    # First non-flag is remote, second is refspec
                    if [ -z "$refspec" ] && [ "$arg" != "$remote" ]; then
                        if [ "$remote" = "origin" ]; then
                            remote="$arg"
                        else
                            refspec="$arg"
                        fi
                    elif [ -z "$refspec" ]; then
                        refspec="$arg"
                    fi
                    ;;
            esac
        done

        # Verify remote is HTTPS
        if ! check_push_remote "$remote"; then
            exit 1
        fi

        # Try to push via gateway
        if check_gateway_available; then
            push_via_gateway "$remote" "$refspec" "$force"
            exit $?
        else
            # Gateway not available - fall back to direct push with warning
            echo "WARNING: Gateway sidecar not available, attempting direct push..." >&2

            # Check GITHUB_TOKEN for fallback
            if [ -z "$GITHUB_TOKEN" ] && [ -z "$GH_TOKEN" ]; then
                cat >&2 << 'EOF'

================================================================================
  GITHUB_TOKEN NOT SET
================================================================================

Cannot push: No GitHub token available and gateway sidecar is not reachable.

Please ensure:
  1. Gateway sidecar is running on the host: systemctl --user status gateway-sidecar
  2. Or GITHUB_TOKEN is set in the container environment

================================================================================

EOF
                exit 1
            fi

            exec "$REAL_GIT" "$@"
        fi
        ;;
    remote)
        # Check for subcommands that modify remotes
        shift  # Remove 'remote' from args
        subcmd=""
        for arg in "$@"; do
            if [[ "$arg" != -* ]]; then
                subcmd="$arg"
                break
            fi
        done
        case "$subcmd" in
            set-url|add|remove|rm|rename|set-head|set-branches|prune)
                show_remote_blocked_message
                exit 1
                ;;
            *)
                # Allow read-only remote commands: show, get-url, -v
                exec "$REAL_GIT" remote "$@"
                ;;
        esac
        ;;
    *)
        # All other commands pass through
        exec "$REAL_GIT" "$@"
        ;;
esac
