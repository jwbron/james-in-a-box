#!/bin/bash
#
# Git wrapper for jib container
# Intercepts git commands to ensure proper authentication and security.
#
# This wrapper is placed in PATH before /usr/bin/git to:
# 1. Block remote URL modifications (URLs are managed by the host)
# 2. Route git push through the gateway sidecar for policy enforcement
#
# Security: Requires gateway sidecar - fails closed if gateway unavailable.
# Authentication is handled by the gateway sidecar which holds the GITHUB_TOKEN.
#

REAL_GIT=/usr/bin/git
GATEWAY_URL="${GATEWAY_URL:-http://jib-gateway:9847}"
GATEWAY_SECRET_FILE="${HOME}/sharing/.gateway-secret"
# Worktree container ID - set by jib launcher to translate container paths
# Container sees ~/repos/X but gateway needs ~/.jib-worktrees/<container-id>/X
# After PR #545, gateway mounts at container paths (/home/jib/...) not host paths
JIB_WORKTREE_HOST_PATH="${JIB_WORKTREE_HOST_PATH:-}"
CONTAINER_REPOS_DIR="${HOME}/repos"
# Fixed container home path (must match gateway's CONTAINER_HOME)
GATEWAY_CONTAINER_HOME="/home/jib"

# Function to translate container path to gateway-accessible path
# Container sees /home/jib/repos/X but gateway needs /home/jib/.jib-worktrees/<id>/X
# Note: Gateway mounts host paths at container paths (PR #545), so we output
# container-style paths, not host paths.
translate_path_for_gateway() {
    local container_path="$1"

    # If no worktree host path is set, return the path as-is
    # (this handles running outside of jib container context)
    if [ -z "$JIB_WORKTREE_HOST_PATH" ]; then
        echo "$container_path"
        return
    fi

    # Check if path is under the container's repos directory
    # e.g., /home/jib/repos/james-in-a-box -> james-in-a-box
    if [[ "$container_path" == "$CONTAINER_REPOS_DIR"/* ]]; then
        # Extract the relative path after ~/repos/
        local relative_path="${container_path#$CONTAINER_REPOS_DIR/}"
        # Extract container ID from JIB_WORKTREE_HOST_PATH
        # e.g., /home/jwies/.jib-worktrees/jib-20260123-000359-244376 -> jib-20260123-000359-244376
        local container_id="${JIB_WORKTREE_HOST_PATH##*/}"
        # Construct the gateway container path (not host path!)
        # Gateway mounts ~/.jib-worktrees at /home/jib/.jib-worktrees
        echo "${GATEWAY_CONTAINER_HOME}/.jib-worktrees/${container_id}/${relative_path}"
    else
        # Not under repos dir, return as-is
        echo "$container_path"
    fi
}

# Function to show remote modification blocked message
show_remote_blocked_message() {
    cat >&2 << 'EOF'

================================================================================
  GIT REMOTE MODIFICATION BLOCKED
================================================================================

Git remote URLs are managed by the HOST and must not be modified.

If you need to interact with a different repository:
  - Clone it fresh or work in a different directory
  - The host manages remote URLs for security

================================================================================

EOF
    return 1
}

# Function to get gateway secret for authentication
get_gateway_secret() {
    if [ -f "$GATEWAY_SECRET_FILE" ]; then
        cat "$GATEWAY_SECRET_FILE"
    else
        echo ""
    fi
}

# Function to check if gateway is available
check_gateway_available() {
    if command -v curl >/dev/null 2>&1; then
        curl -s --connect-timeout 2 "${GATEWAY_URL}/api/v1/health" >/dev/null 2>&1
        return $?
    fi
    return 1
}

# Function to push via gateway
# Args: remote refspec force [work_dir]
push_via_gateway() {
    local remote="$1"
    local refspec="$2"
    local force="$3"
    local work_dir="${4:-}"
    local container_path
    local repo_path

    # Use provided work_dir or current directory
    if [ -n "$work_dir" ]; then
        # Convert to absolute path if relative
        if [[ "$work_dir" != /* ]]; then
            container_path="$(pwd)/$work_dir"
        else
            container_path="$work_dir"
        fi
    else
        container_path=$(pwd)
    fi

    # Translate container path to host path for gateway
    # Container sees ~/repos/X but gateway needs ~/.jib-worktrees/<id>/X
    repo_path=$(translate_path_for_gateway "$container_path")

    # Get authentication secret
    local secret
    secret=$(get_gateway_secret)
    if [ -z "$secret" ]; then
        echo "ERROR: Gateway secret not available at $GATEWAY_SECRET_FILE" >&2
        echo "The gateway sidecar must be running and properly configured." >&2
        return 1
    fi

    # Build JSON payload - escape special characters properly
    # Use Python-style booleans (capitalized) since they're interpolated into Python code
    local force_json="False"
    [ "$force" = "true" ] && force_json="True"

    local payload
    payload=$(python3 -c "
import json
print(json.dumps({
    'repo_path': '$repo_path',
    'remote': '$remote',
    'refspec': '$refspec',
    'force': $force_json
}))
")

    # Call gateway with authentication
    local response
    local http_code
    response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $secret" \
        -d "$payload" \
        "${GATEWAY_URL}/api/v1/git/push" 2>&1)

    # Split response and status code
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Parse response
    local success
    local message
    success=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('success', False))" 2>/dev/null)
    message=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('message', 'Unknown error'))" 2>/dev/null)

    if [ "$success" = "True" ]; then
        # Show stdout/stderr from the push
        local stdout stderr
        stdout=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('data', {}).get('stdout', ''))" 2>/dev/null)
        stderr=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('data', {}).get('stderr', ''))" 2>/dev/null)
        [ -n "$stdout" ] && echo "$stdout"
        [ -n "$stderr" ] && echo "$stderr" >&2
        return 0
    else
        # Show error message
        echo "ERROR: $message" >&2

        # Show details if available
        local details
        details=$(echo "$response" | python3 -c "import sys, json; d=json.load(sys.stdin).get('data', {}); print(d.get('stderr', '') if d else '')" 2>/dev/null)
        [ -n "$details" ] && echo "$details" >&2

        # Special handling for different error codes
        case "$http_code" in
            401)
                cat >&2 << 'EOF'

================================================================================
  AUTHENTICATION FAILED
================================================================================

The gateway sidecar rejected the authentication token.

Please ensure the gateway secret is correctly configured:
  - Host: ~/.config/jib/gateway-secret
  - Container: ~/sharing/.gateway-secret

================================================================================

EOF
                ;;
            403)
                cat >&2 << 'EOF'

================================================================================
  PUSH BLOCKED BY POLICY
================================================================================

The gateway sidecar blocked this push operation.

To push, ensure one of the following:
  1. Use a jib-prefixed branch name: jib-* or jib/*
  2. Create a PR from this branch first (the branch will then be owned by jib)

================================================================================

EOF
                ;;
            429)
                cat >&2 << 'EOF'

================================================================================
  RATE LIMIT EXCEEDED
================================================================================

Too many push operations. Please wait before trying again.

================================================================================

EOF
                ;;
        esac

        return 1
    fi
}

# Function to check if push target is HTTPS (we don't have SSH keys)
# Args: remote [work_dir]
check_push_remote() {
    local remote="${1:-origin}"
    local work_dir="${2:-}"

    # Build git command with optional -C flag
    local git_cmd=("$REAL_GIT")
    if [ -n "$work_dir" ]; then
        git_cmd+=("-C" "$work_dir")
    fi

    # Get the remote URL
    local url
    url=$("${git_cmd[@]}" remote get-url "$remote" 2>/dev/null)

    if [ -z "$url" ]; then
        echo "ERROR: Remote '$remote' not found" >&2
        return 1
    fi

    # Check if it's SSH - we can't push via SSH (no keys in container)
    if [[ "$url" == git@* ]] || [[ "$url" == ssh://* ]]; then
        cat >&2 << EOF

================================================================================
  SSH PUSH NOT SUPPORTED
================================================================================

Remote '$remote' uses SSH: $url

This container doesn't have SSH keys. To push, you have two options:

1. Change the remote URL on the HOST to HTTPS:
   git remote set-url $remote https://github.com/OWNER/REPO.git

2. Or push from the host machine directly

================================================================================

EOF
        return 1
    fi

    return 0
}

# Parse global git options and extract the actual command
# Global options like -C, -c, --git-dir, --work-tree take arguments
# We need to skip both the flag and its argument to find the real command
cmd=""
git_work_dir=""  # Track -C option for push operations
args_after_globals=()  # Arguments after global options (command + its args)
skip_next=false
capture_work_dir=false  # Flag to capture next arg as -C value
found_command=false

for arg in "$@"; do
    # Handle deferred captures from previous iteration
    if $capture_work_dir; then
        git_work_dir="$arg"
        capture_work_dir=false
        continue
    fi

    if $skip_next; then
        skip_next=false
        continue
    fi

    if ! $found_command; then
        case "$arg" in
            # -C <path> - run as if started in <path>
            # We need to capture this for push operations
            -C)
                capture_work_dir=true
                ;;
            # Other global options that take an argument (next arg)
            -c|--git-dir|--work-tree|--namespace|--super-prefix|--config-env)
                skip_next=true
                ;;
            # Global options with = syntax (value attached)
            -C=*|--git-dir=*|--work-tree=*|-c=*|--namespace=*|--super-prefix=*|--config-env=*)
                # Extract value for -C if present
                if [[ "$arg" == -C=* ]]; then
                    git_work_dir="${arg#-C=}"
                fi
                ;;
            # Global flags (no argument)
            --version|--help|--html-path|--man-path|--info-path|-p|--paginate|-P|--no-pager|--no-replace-objects|--bare|--literal-pathspecs|--glob-pathspecs|--noglob-pathspecs|--icase-pathspecs|--no-optional-locks|--list-cmds=*)
                ;;
            # Unknown flag before command
            -*)
                # Pass through unknown flags. Note: if git adds a new global option
                # that takes an argument, we'd incorrectly treat its value as the
                # command. Low risk since we cover all documented global options.
                args_after_globals+=("$arg")
                ;;
            *)
                # Found the command
                cmd="$arg"
                found_command=true
                args_after_globals+=("$arg")
                ;;
        esac
    else
        # Already found command, collect remaining args
        args_after_globals+=("$arg")
    fi
done

case "$cmd" in
    push)
        # Extract remote and refspec from push command
        # git push [options] [remote] [refspec...]
        remote="origin"
        refspec=""
        force="false"
        skip_next=false
        remote_seen=false  # Track if we've explicitly seen a remote arg

        for arg in "${args_after_globals[@]}"; do
            if $skip_next; then
                skip_next=false
                continue
            fi

            case "$arg" in
                push)
                    continue
                    ;;
                -f|--force|--force-with-lease*)
                    force="true"
                    ;;
                -u|--set-upstream)
                    # -u takes no extra argument
                    ;;
                --repo|--receive-pack|--exec|-o|--push-option)
                    # These flags take an argument
                    skip_next=true
                    ;;
                -*)
                    # Other flags, ignore
                    ;;
                *)
                    # First non-flag is remote, second is refspec
                    # Use remote_seen flag to handle "git push origin branch" correctly
                    if [ "$remote_seen" = "false" ]; then
                        remote="$arg"
                        remote_seen=true
                    elif [ -z "$refspec" ]; then
                        refspec="$arg"
                    fi
                    ;;
            esac
        done

        # Verify remote is HTTPS (pass work_dir if -C was used)
        if ! check_push_remote "$remote" "$git_work_dir"; then
            exit 1
        fi

        # Gateway is REQUIRED - fail closed if not available
        if ! check_gateway_available; then
            cat >&2 << 'EOF'

================================================================================
  GATEWAY SIDECAR NOT AVAILABLE
================================================================================

Cannot push: The gateway sidecar is required but not reachable.

The gateway enforces ownership policies and holds GitHub credentials.
Without it, push operations are not allowed.

Please ensure:
  1. Gateway sidecar is running on the host:
     systemctl --user status gateway-sidecar

  2. The container can reach the gateway:
     curl http://jib-gateway:9847/api/v1/health

================================================================================

EOF
            exit 1
        fi

        push_via_gateway "$remote" "$refspec" "$force" "$git_work_dir"
        exit $?
        ;;
    remote)
        # Check for subcommands that modify remotes
        # Find subcmd in args_after_globals (skip 'remote' itself)
        subcmd=""
        for arg in "${args_after_globals[@]}"; do
            # Skip 'remote' command itself
            if [ "$arg" = "remote" ]; then
                continue
            fi
            # Skip flags
            if [[ "$arg" != -* ]]; then
                subcmd="$arg"
                break
            fi
        done
        case "$subcmd" in
            set-url|add|remove|rm|rename|set-head|set-branches|prune)
                show_remote_blocked_message
                exit 1
                ;;
            *)
                # Allow read-only remote commands: show, get-url, -v
                exec "$REAL_GIT" "$@"
                ;;
        esac
        ;;
    *)
        # All other commands pass through
        exec "$REAL_GIT" "$@"
        ;;
esac
